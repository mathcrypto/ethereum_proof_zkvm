    // Execut// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
/* use methods::{
    ETHEREUM_PROOF_GUEST_ELF, ETHEREUM_PROOF_GUEST_ID
};
*/



use risc0_zkvm::{default_prover, ExecutorEnv};
use sha2::{Sha256, Digest as ShaDigest};
use risc0_zkvm::sha::Digest;
use serde::{Serialize, Deserialize};
use ethers::prelude::*;
use std::convert::TryInto;
use hex; 
use ethers::types::U256;


const ETHEREUM_PROOF_GUEST_ELF: &str = "../methods/guest/target/riscv32im-risc0-zkvm-elf/docker/ethereum_proof_guest";
const ETHEREUM_PROOF_GUEST_ID: &str = "d5ce7284368ae6712ec225d58133e60408b408f1925c38e534b749f568d84e36";


#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EthereumBlock {
    pub hash: String,
    pub parent_hash: String,
    pub timestamp: U256,
    pub number: U64,
    pub transactions_root: String,
}

async fn get_ethereum_block() -> Result<EthereumBlock, Box<dyn std::error::Error>> { 

    // Set up Ethereum provider (Infura or other Ethereum node)
    let provider = Provider::<Http>::try_from("https://mainnet.infura.io/v3/YOUR_INFURA_PROJECT_ID")?;

    // Fetch the latest block
    let block = provider.get_block(BlockId::Number(BlockNumber::Latest)).await?;

    match block {
        Some(block) => {
            let hash = format!("{:?}", block.hash);
            let parent_hash = block.parent_hash.to_string();
            let timestamp = block.timestamp;
            let number = block.number.unwrap_or(U64::zero());  // Default to U64::zero() if None     
            let transactions_root = block.transactions_root.to_string();
            Ok(EthereumBlock {
                hash,
                parent_hash,
                timestamp,
                number,
                transactions_root,
            })
        },
        None => Err("Block not found".into()),
    }

}
                   
               
     

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call

    // Step #1: Create a sample Ethereum block header.
   /* let ethereum_block = EthereumBlock {
        hash: "0x1234567890abcdef".to_string(),
        parent_hash: "0xabcdef1234567890".to_string(),
        timestamp: 1631583200,
        number: 123456,
        transactions_root: "0xabcdefabcdefabcdef".to_string(),
    };
    */
    let ethereum_block = get_ethereum_block().await?;
    println!("Fetched Ethereum Block {:?}", ethereum_block);
    

    // Step #2: Write the block to the executor environment.
    // The ExecutorEnv is used to define the environment in which the zkVM will execute. 
   
    let env = ExecutorEnv::builder()
        .write(&ethereum_block)
        .unwrap()
        .build()
        .unwrap();

     println!("Generating proof for the block ...");
    // Obtain the default prover to generate a proof.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let elf_path = std::fs::read(ETHEREUM_PROOF_GUEST_ELF).expect("Failed to read ELF file");
    let prove_info = prover
        .prove(env, &elf_path)
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    // TODO: Implement code for retrieving receipt journal here.
    // Decode the hexadecimal string into a byte vector
    let bytes = hex::decode(ETHEREUM_PROOF_GUEST_ID).expect("Failed to decode hex string");

    // Convert the byte vector into a fixed-size array of 32 bytes
    let bytes_array: [u8; 32] = bytes.try_into().expect("Failed to convert to 32-byte array");

    // Convert the byte array into a Digest
    let guest_id_digest = Digest::from(bytes_array);

    // Now you can use guest_id_digest in your code
    println!("{:?}", guest_id_digest);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(guest_id_digest)
        .unwrap();
    Ok(())

}
// Helper function to convert a string into a Digest using SHA256
fn hash_to_digest(input: String) -> Digest {
    let mut hasher = Sha256::new();
    hasher.update(input.as_bytes());
    let result = hasher.finalize();
    let fixed_size_array: [u8; 32] = result.into();
    Digest::from(fixed_size_array)
}

